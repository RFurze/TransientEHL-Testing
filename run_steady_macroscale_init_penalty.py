#!/usr/bin/env python3
"""Initialise the macroscale solver and persist its initial state.

The solver performs one "fast" load-balance iteration and stores the
resulting fields for downstream scripts:

* ``p_init.npy`` - pressure vector used as the starting point for later
  macroscale solves.
* ``Q_init.npy``/``h_init.npy``/``f_init.npy`` - initial flux, film
  thickness and fluid fraction.
* ``xi_rot.npy`` - rotated field vector that seeds microscale tasks.
* ``beta.npy`` - nondimensional cavitation parameter passed to
  microscale solvers.

Command line options (from :func:`parse_common_args`): ``--lb_iter``,
``--c_iter`` and ``--output_dir``.
"""
import os
import sys
import argparse
from utils.cli import parse_common_args

import numpy as np
import matplotlib.pyplot as plt
from fenics import *

set_log_level(LogLevel.ERROR)
from dataclasses import asdict
from CONFIGPenalty import material, mesh, solver as solver_params

# Import Macroscale solver
from macroscale.src.functions.macro_HMM_penalty_transient_EHL import (
    material_parameters,
    mesh_parameters,
    solver_parameters,
    meshfn,
    EHLSolver,
)


def main():
    """Build the solver, run a single load-balance solve and record state."""
    args = parse_common_args("Initialise Macroscale Problem")

    output_dir = os.path.join(args.output_dir)
    os.makedirs(output_dir, exist_ok=True)

    load_balance_err = 1.0
    coupling_err = 1.0
    # Create the solver and initialise rotation matrices.  The rotation
    # matrices are either read from ``data/output`` (if present) or
    # generated by :meth:`HydroSolver.initialise_imported_rotation` and
    # stored there for subsequent runs.
    solver = EHLSolver(
        meshfn(mesh_parameters(**asdict(mesh))),
        material_parameters(**asdict(material)),
        solver_parameters(**asdict(solver_params)),
        os.path.basename(output_dir),
    )

    # if os.path.exists(
    #     os.path.join("data/output/", "rotation_matrix.npy")
    # ) and os.path.exists(os.path.join("data/output/", "rotation_matrix_inverse.npy")):
    #     print("Using existing rotation matrices from data/output/")
    #     solver.initialise_imported_rotation()
    # else:
    #     print("Creating rotation matrices in data/output/")
    #     solver.export_rotation()
    # solver.export_rotation()        
    solver.initialise_imported_rotation()

    # Update the contact separation based on the nominal eccentricity, with no deformation
    solver.update_contact_separation(
        solver.material_properties.eccentricity0, HMMState=False, transientState=False, EHLState=False
    )

    # Perform the initial load-balance solve and compute derived fields.
    print("Running initial macroscale load-balance solve...")
    xi_initial = solver.solve_loadbalance_EHL()

    solver.calcQ()
    solver.calc_gradP()
    p_max_init = np.max(solver.p.vector()[:])
    force_init = solver.force
    # Load balance error for initialisation step
    load = solver.load
    diff_z = load[2] + solver.force[2]
    denom  = abs(load[2]) if abs(load[2]) > 0 else 1.0
    load_balance_err = float(diff_z) / denom

    print(f"Initial macroscale solve complete — p_max={p_max_init:.3e}")
    solver.export('p', tag="out", iter=0)
    # Write visualisation files and numpy arrays used by later stages.
    np.save(os.path.join(args.output_dir, "p_init.npy"), solver.p.vector()[:])
    np.save(os.path.join(args.output_dir, "def_init.npy"), solver.delta.vector()[:] )
    np.save(os.path.join(args.output_dir, "Q_init.npy"), solver.Q.vector()[:])
    np.save(os.path.join(args.output_dir, "h_init.npy"), solver.h.vector()[:])

    # Rotated xi field is used by 1_downsample.py to build microscale tasks
    xi_rot = solver.rotate_xi()
    np.save(os.path.join(args.output_dir, "xi_rot.npy"), xi_rot)

    print(f"Initialisation step load balance error ={load_balance_err}")

    # Initialise diagnostic logs used for convergence checks in later iterations
    load_bal_err_init = 1
    coupling_err_init = 1
    with open(os.path.join(args.output_dir, "coupling_error.txt"), "a") as f:
        f.write(f"{coupling_err_init}\n")
    with open(os.path.join(args.output_dir, "load_balance_err.txt"), "a") as f:
        f.write(f"{load_bal_err_init}\n")
    with open(os.path.join(args.output_dir, "eccentricities.txt"), "a") as f:
        f.write(f"{solver.material_properties.eccentricity0[2]}\n")
    with open(os.path.join(args.output_dir, "forces.txt"), "a") as f:
        f.write(f"{solver.force}\n")

    print("macro_init.py completed successfully.")

    # ------------------ DIAGNOSTIC: save → reload → compare ------------------
    # Take a reference snapshot of the *current* (in-memory) state produced by init
    ref_snapshot = solver.snapshot_state()

    # Load back what we just saved, into the *same* solver instance
    p_loaded   = np.load(os.path.join(args.output_dir, "p_init.npy"))
    d_loaded   = np.load(os.path.join(args.output_dir, "def_init.npy"))
    h_loaded   = np.load(os.path.join(args.output_dir, "h_init.npy"))

    # Overwrite the fields in the class with the saved arrays
    solver.load_state(p_loaded, d_loaded, h=h_loaded)

    # Compare the reloaded current state vs the pre-reload reference
    solver.compare_loaded_state(ref_snapshot)
    # -------------------------------------------------------------------------

    print("macro_init.py completed successfully.")    


if __name__ == "__main__":
    main()
